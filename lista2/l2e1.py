# Reference off implementation
# http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
from l1e3 import multiGF as mgf,somaGF as sgf

s_box = [
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] 

inv_s_box = [
0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 
0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 
0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 
0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 
0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 
0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 
0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 
0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 
0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 
0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 
0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 
0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 
0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 
0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 
0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 
0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]

table_mix_columns = [2,3,1,1,1,2,3,1,1,1,2,3,3,1,1,2]
inv_table_mix = [ 0xe,0xb,0xd,0x9,0x9,0xe,0xb,0xd,0xd,0x9,0xe,0xb,0xb,0xd,0x9,0xe]
round_constants = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B,0x36]

def cipher_aes(block_byte,number_rounds,keys):
    a = block_to_byte(block_byte)
    a = add_round_key(a,keys[:16])
    #print(a)
    k=0
    for i in range(1,number_rounds):
        a = invert_block_bytes(a)
        a = sub_bytes(a,s_box)
        a = shift_rows(a,True)
        a = mix_columns(a,table_mix_columns)
        a = add_round_key(invert_block_bytes(a),keys[16*i:16*i+16])
        #print( a)
        k=i
    k+=1
    a = sub_bytes(invert_block_bytes(a),s_box)
    a = shift_rows(a,True)
    a = add_round_key(invert_block_bytes(a),keys[16*k:16*k+16])
    return a

def decryptor(block_byte,number_rounds,keys):
 #   a = block_to_byte(block_byte)
    a = block_byte
    k=10
    a = add_round_key(a,keys[16*k:16*k+16])
    a = invert_block_bytes(a)
    #print(a)
    for i in range(number_rounds-1,0,-1):
        a = shift_rows(a,False)
        a = sub_bytes(a,inv_s_box)
        a = add_round_key(invert_block_bytes(a),keys[16*i:16*i+16])
        a = invert_block_bytes(a)
        a = mix_columns(a,inv_table_mix)
        #print(invert_block_bytes(a))
    a = shift_rows(a,False)
    a = sub_bytes(a,inv_s_box) 
    a = add_round_key(invert_block_bytes(a),keys[:16])
    return a

def aes(password,text,operation):
    keys = key_expansion(password)
    text = transform_text_int(text)
    data = []
    for blocks in range(0,len(text),16):
        if operation == "e":
            data.extend(cipher_aes(text[blocks:blocks+16],10,keys))
        else:
            data.extend(decryptor(text[blocks:blocks+16],10,keys))
    if operation == 'd':
        while data[-1] == 0:
            data.pop() 
    #print([chr(x) for x in data])
    #print("\n\n")
    return data

def sub_bytes(state, substitution_box):
    # Obtain the numbers of index for sub_bytes table substitution (0..15, 0..15)
    # from the array of bits '00000001' -> ('0000','0001')
    state = [ bin( byte_state|256 )[3:] for byte_state in state ]
    index_sub_bytes = [ (int( bytes_string[0:4],2 ), int(bytes_string[4:8],2) ) for bytes_string in state ]
    
    # Make the ubstitution
    substituted_bytes = [substitution_box[index[0]*16+index[1]] for index  in index_sub_bytes]
    #print("sub_bytes")
    return substituted_bytes

def shift_rows(state,encription):
    row_one = 4
    row_two = 4*2
    row_three = 4*3
    # Shift manualy
    if encription:
        state_shift = [state[0], state[1],state[2],state[3],
            state[row_one+1], state[row_one+2], state[row_one+3], state[row_one+0],
            state[row_two + 2], state[row_two+3], state[row_two], state[row_two+1],
            state[row_three+3], state[row_three], state[row_three+1], state[row_three+2] ]
    else:
        state_shift = [state[0], state[1],state[2],state[3],
            state[row_one+3], state[row_one+0], state[row_one+1], state[row_one+2],
            state[row_two + 2], state[row_two+3], state[row_two], state[row_two+1],
            state[row_three+1], state[row_three+2], state[row_three+3], state[row_three+0] ]

    #print("shift_rows")
    return state_shift

def mix_columns(state,table_mix):
    result_mix = [0 for x in state]

    # Matrix multiplication by a vector
    for cols in range(4):
        for rows in range(4):
            result = 0
            for i in range(4):
                result = sgf(result,mgf(table_mix[rows*4+i] ,state[cols+4*i]))
            result_mix[cols+4*rows] = result
    #print("mix_columns")
    return result_mix


def add_round_key(state,key_round):
    # Make a XOR with the key and state array
    state_xor = [ value_byte[0]^value_byte[1] for value_byte in zip(state,key_round) ]
    #print("add_round_key")
    return state_xor

def key_expansion(key):
    keys = transform_text_int(key)
    # Generate the 44 keys based in the original key
    # Make a xor with the word of last block with the last block
    # W(k+1) = W(k) ^ W(k-4)
    for i in range(10):
        # Apply the function in the last word of the block
        final_word_xor = word_xor(keys[-4:], round_constants[i])
        new_keys = [ (keys[ -16+i ] ^ final_word_xor[i]) for i in range(4) ]
        keys.extend(new_keys)
        for j in range(3):
            keys.extend([ keys[-4+k]^keys[-16+k] for k in range(4) ])

    return keys

def word_xor(key,constant):
    # Circular shift
    key.append(key[0])
    key.pop(0)
    
    # Apply substitution box
    word_xor = sub_bytes(key,s_box)
    #print("sub"+str(word_xor))
    
    # Make the xor with constant (x,0,0,0)
    final_word_xor =  [ word_xor[0] ^ constant, word_xor[1],word_xor[2],word_xor[3]]
    #print("xor"+str(final_word_xor))
    return final_word_xor 

def block_to_byte(block):
    # Transform bytes in a multiple array of bits in string format
    # Add a 9th bit to that number, because transformation of bin()
    # Only generate the the bin with most significante bit size 8 -> '1000'
    # Then, remove the elements 0b1 off bits in string format (Ex.: ['00000001','10111101',10101010'])
    char_to_bits = [ byte_state for byte_state in block ] 
    return char_to_bits

def invert_block_bytes(block):
    block_inverted = [ 0 for x in block] # Initialize with 0 the size of block
    for i in range( len(block)):
        row = int(i/4) # The row index in the array used to represent a matrix
        column = i%4 # The column value
        block_inverted[ column*4 + row]  = block[row*4+column] # Invert positions

    return block_inverted

def transform_text_int(data):
    int_data = [ ord(x) for x in data]
    if len(int_data) %16 !=0:
        for i in range(16-(len(int_data)%16)):
            int_data.append(0)
    return int_data
if __name__ == "__main__":
    data = aes("cccccccccccccccc","Uma mensagem de teste para criptografar",'e')
    print(''.join([chr(x) for x in data]))
    data = aes("cccccccccccccccc",''.join([chr(x) for x in data]),'d')
    print(''.join([chr(x) for x in data]))
 
